<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (GA4) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-27SVZGYHZ3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-27SVZGYHZ3');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeVoxelProbes v1.3</title>
    <meta name="description" content="Interactive Three.js demo of 'VibeVoxelProbes', a dynamic voxel-based global illumination approximation prototype. Explore real-time lighting by Trent 'Tront' Sterling.">
    <meta name="keywords" content="VibeVoxelProbes, voxel lighting, global illumination, Three.js, WebGL, real-time graphics, lighting simulation, Trent Sterling, Tront, vibecoding, game development, graphics programming">
    <link rel="canonical" href="https://tront.xyz/vibevoxelprobes/" />

    <meta property="og:title" content="VibeVoxelProbes v1.3 - Interactive Lighting Demo">
    <meta property="og:description" content="Explore a CPU-based prototype of a dynamic voxel lighting system with multiple lights, probes, extensive controls, and real-time updates. A 'vibecoded' project by Trent 'Tront' Sterling.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://tront.xyz/vibevoxelprobes/">
    <meta property="og:image" content="https://blog.tront.xyz/assets/img/tront.png">
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="400">
    <meta property="og:image:height" content="400">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://tront.xyz/vibevoxelprobes/">
    <meta name="twitter:title" content="VibeVoxelProbes v1.3 - Interactive Lighting Demo">
    <meta name="twitter:description" content="Explore a CPU-based prototype of a dynamic voxel lighting system by Trent 'Tront' Sterling.">
    <meta name="twitter:image" content="https://blog.tront.xyz/assets/img/tront.png">

    <link rel="icon" href="https://blog.tront.xyz/assets/img/tront.png" type="image/png">
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1d24; color: #e8e8e8; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        :root {
            --lil-gui-background-color: #252526; --lil-gui-text-color: #d4d4d4;
            --lil-gui-title-background-color: #1e1e1e; --lil-gui-widget-color: #3c3c3c;
            --lil-gui-hover-color: #4a4a4a; --lil-gui-focus-color: #569cd6;
            --lil-gui-number-color: #b5cea8; --lil-gui-string-color: #ce9178;
        }
        .lil-gui { --font-size: 13px; --input-font-size: 13px; --widget-padding: 3px; --widget-border-radius: 2px; --name-width: 48%; z-index: 100 !important; }
        .lil-gui .title { font-weight: bold; color: #569cd6; }
        .lil-gui .folder .title { font-size: 0.95em; } 
        .lil-gui .folder .folder .title { font-size: 0.9em; } 
        .info-toggle-button { position: fixed; top: 10px; left: 10px; z-index: 101; padding: 8px 12px; background-color: rgba(40,45,55,0.8); color: #e8e8e8; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; cursor: pointer; font-size: 14px; backdrop-filter: blur(4px); }
        .info-toggle-button:hover { background-color: rgba(50,55,65,0.9); }
        #info-panel { position: fixed; top: 50px; left: 10px; width: calc(100% - 40px); max-width: 450px; max-height: calc(100vh - 70px); background-color: rgba(30,30,35,0.92); border: 1px solid rgba(255,255,255,0.15); border-radius: 6px; padding: 15px 20px; box-sizing: border-box; z-index: 100; overflow-y: auto; font-size: 14px; line-height: 1.6; display: block; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        #info-panel.hidden { display: none !important; }
        #info-panel h2 { color: #569cd6; margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 0.3em; }
        #info-panel p, #info-panel li { color: #c8c8c8; margin-bottom: 0.8em; }
        #info-panel ul { padding-left: 20px; margin-top: 0.5em; }
        #info-panel strong { color: #9cdcfe; }
        #info-panel code { background-color: rgba(0,0,0,0.3); padding: 0.1em 0.3em; border-radius: 3px; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
        #info-panel a { color: #4ec9b0; text-decoration: none; }
        #info-panel a:hover { text-decoration: underline; }
        .info-date { font-size: 0.9em; color: #888; text-align: right; margin-bottom: 1em; }
    </style>
</head>
<body>
    <button class="info-toggle-button" id="infoButton">Hide Info</button>
    <div id="info-panel">
        <h2>VibeVoxelProbes Demo v1.3</h2>
        <p class="info-date" id="infoPanelDate"></p>
        <p>This Three.js demo is a rapid prototype of <strong>"VibeVoxelProbes"</strong>, a dynamic, voxel-based global illumination approximation, "vibecoded" by <strong>Trent "Tront" Sterling</strong> and AI assistant (Gemini 2.5 Pro Preview 05-06). It serves as a conceptual testbed for a high-performance lighting system intended for Unity, particularly for VR and other performance-constrained platforms.</p>
        <p><strong>Core Concept: "Light Probes on Crack"</strong><br>
        The system aims to replace expensive traditional real-time dynamic lighting (per-pixel or per-vertex) with a more performant and scalable solution. It works by baking lighting information (dominant direction, color, and directional coherence/spread) from multiple dynamic light sources into a relatively low-resolution 3D voxel grid. Meshes in the scene then sample this single 3D data structure (conceptually a 3D texture) to determine their lighting. This trades some VRAM (for the voxel data) for significantly increased rendering speed, as the cost per mesh becomes a fixed lookup rather than iterating through many lights.</p>
        <strong>Advantages Over Traditional Methods:</strong>
        <ul>
            <li><strong>Performance & Scalability:</strong> Efficiently handles many dynamic lights, ideal for forward rendering.</li>
            <li><strong>Improved Visuals vs. Vertex Lit:</strong> Avoids common vertex lighting issues like "long triangle" artifacts and LOD pop-in, while providing spatially consistent lighting.</li>
            <li><strong>Normal Mapping Support:</strong> The per-pixel light direction sampled from the grid allows for proper use of normal maps.</li>
            <li><strong>Static Light Optimization:</strong> If lights don't move, the voxel grid isn't rebaked, becoming extremely fast.</li>
            <li><strong>Efficient Updates (Future):</strong> A Unity version would leverage compute shaders for partial/patched grid updates.</li>
        </ul>
        <strong>Lighting Model in this Demo:</strong>
        <p>This prototype focuses on a single dominant light direction (blended weighted average from point lights + a global ambient directional base), an accumulated light color, and a calculated "directional coherence" (spread factor) per voxel. Probe spheres use a Half-Lambert diffuse model (blended with an omni-directional term based on coherence) for soft falloff, combined with a Blinn-Phong specular component for highlights.</p>
        <strong>Features Demonstrated:</strong>
        <ul>
            <li>CPU-based real-time baking (up to 20 dynamic lights).</li>
            <li>Blended dominant light direction, accumulated color, and directional coherence per voxel.</li>
            <li>Visualization of dominant light directions.</li>
            <li>Movable and static "probe spheres" sampling the voxel grid.</li>
            <li>Inverted hull rendering for voxels; surrounding encasing box.</li>
            <li>Dynamically adjustable grid resolution, voxel size, and number of active lights.</li>
            <li>Extensive GUI controls.</li>
        </ul>
        <p>This collaborative prototype helps visualize and refine "VibeVoxelProbes" concepts before full-scale Unity development.</p>
        <p>Learn more about "Vibecoding" at <a href="https://blog.tront.xyz/posts/vibe-coding-gemini/" target="_blank" rel="noopener noreferrer">Tront's Blog</a>.</p>
    </div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        let scene, camera, renderer, controls, clock, gui;
        let voxelGrid = [], voxelMeshes = [], lights = [], lightHelpers = [];
        let encasingBoxMesh, ambientLight;
        let dominantDirectionLinesMesh, dominantDirectionLinesGeometry, dirLinePositions, dirLineColors;
        let visibleDirLinesCount = 0;
        let boundsFolderGUI; 
        let movableProbeSphere, movableProbeSphereMaterial;
        let cornerProbes = []; 
        let lightGUIfolders = []; 

        let GRID_RESOLUTION = 8;
        let VOXEL_PHYSICAL_SIZE = 1.0; 
        let HALF_GRID_WORLD_SIZE = GRID_RESOLUTION * VOXEL_PHYSICAL_SIZE / 2;
        
        const MAX_POSSIBLE_LIGHTS = 20; 

        const params = {
            gridResolution: "8", voxelPhysicalSize: 1.0, showLightHelpers: true, simulationSpeed: 1.0,
            numActiveLights: 6, 
            sceneAmbientLight: { color: 0x45747f, intensity: 0.3 },
            globalAmbientDirectional: { directionX:0.5,directionY:0.7,directionZ:0.2,color:0xffffff,intensity:0.0 },
            lightMovementBounds: { minX:0,maxX:0,minY:0,maxY:0,minZ:0,maxZ:0 },
            encasingBox: { visible: false, opacity: 0.5, color: 0x000000, padding: 0.0 },
            voxelVisuals: { minOpacity:0.0,maxOpacity:1.0,emissiveStrength:1.0,intensityCap:50.0, omniDiffuseBase: 1.0 },
            lightHelperProps: { sphereSize: 0.25, depthTest: false },
            debugVisuals: { showDominantDirection:true,directionLineLength:0.4,directionMinIntensity:2.0 },
            probeSystem: { movableProbeVisible:true,cornerProbesVisible:true,radius:0.5,color:0xcccccc, roughness:0.5,metalness:0.1, movableProbePosX:0,movableProbePosY:0,movableProbePosZ:0 },
            lightsParams: [] 
        };

        const defaultLightColors = [0xffaa55,0x55aaff,0x55ffaa,0xff55aa,0xffdd33,0x33ddff,0xaa33ff,0xff8800,0x00ff88,0x8800ff,0xf0f0f0,0xf08080,0x80f080,0x8080f0,0xf0f080,0xf080f0,0x80f0f0,0xdaa520,0x20b2aa,0x778899];
        for (let i = 0; i < MAX_POSSIBLE_LIGHTS; i++) { params.lightsParams.push({ intensity: 3.0 + (Math.random()*0.5), range: 4+(Math.random()*3), color: defaultLightColors[i % defaultLightColors.length], initialY:0, helperOpacity:0.7 }); }
        
        function getGlobalAmbientDir() { return new THREE.Vector3(params.globalAmbientDirectional.directionX,params.globalAmbientDirectional.directionY,params.globalAmbientDirectional.directionZ).normalize(); }
        function initParams() { GRID_RESOLUTION = parseInt(params.gridResolution); VOXEL_PHYSICAL_SIZE = params.voxelPhysicalSize; HALF_GRID_WORLD_SIZE = GRID_RESOLUTION*VOXEL_PHYSICAL_SIZE/2; const worldExtent = GRID_RESOLUTION*VOXEL_PHYSICAL_SIZE; const defaultBoundPadding = VOXEL_PHYSICAL_SIZE*0.8; params.lightMovementBounds = {minX:-HALF_GRID_WORLD_SIZE+defaultBoundPadding,maxX:HALF_GRID_WORLD_SIZE-defaultBoundPadding,minY:-HALF_GRID_WORLD_SIZE+defaultBoundPadding,maxY:HALF_GRID_WORLD_SIZE-defaultBoundPadding,minZ:-HALF_GRID_WORLD_SIZE+defaultBoundPadding,maxZ:HALF_GRID_WORLD_SIZE-defaultBoundPadding,}; params.debugVisuals.directionLineLength = VOXEL_PHYSICAL_SIZE*0.4; params.probeSystem.radius = VOXEL_PHYSICAL_SIZE * 0.5; params.lightsParams.forEach((lp,i) => { lp.initialY = HALF_GRID_WORLD_SIZE * ((i%4/3)*0.6-0.3); }); }
        initParams(); 

        const lightHelperVertexShader = `varying float vNdotV; void main() { vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); vec3 vNormal = normalize(normalMatrix * normal); vec3 vViewPosition = -mvPosition.xyz; vNdotV = max(0.0, dot(vNormal, normalize(vViewPosition))); gl_Position = projectionMatrix * mvPosition; }`;
        const lightHelperFragmentShader = `uniform vec3 uColor; uniform float uOverallOpacity; varying float vNdotV; void main() { float opacity = pow(1.0 - vNdotV, 1.5) * 0.7 + 0.1; opacity *= uOverallOpacity; gl_FragColor = vec4(uColor, clamp(opacity, 0.0, 1.0)); }`;
        const probeVertexShader = `varying vec3 vWorldPosition; varying vec3 vWorldNormal; void main() { vec4 worldPos = modelMatrix * vec4(position, 1.0); vWorldPosition = worldPos.xyz; vWorldNormal = normalize( mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz) * normal ); gl_Position = projectionMatrix * viewMatrix * worldPos; }`;
        const probeFragmentShader = `uniform vec3 uBaseColor; uniform float uRoughness; uniform float uMetalness; uniform vec3 uVoxelLightDirection; uniform vec3 uVoxelLightColor; uniform vec3 uAmbientLightColor; uniform float uVoxelDirectionCoherence; uniform float uOmniDiffuseBase; varying vec3 vWorldPosition; varying vec3 vWorldNormal; void main() { vec3 N = normalize(vWorldNormal); vec3 L = normalize(uVoxelLightDirection); float NdotL = dot(N, L); float directionalDiffuseFactor = (NdotL * 0.5 + 0.5); directionalDiffuseFactor *= directionalDiffuseFactor; float blendedDiffuseTerm = mix(uOmniDiffuseBase, directionalDiffuseFactor, uVoxelDirectionCoherence); vec3 diffuseLighting = uVoxelLightColor * blendedDiffuseTerm; vec3 V = normalize(cameraPosition - vWorldPosition); vec3 H = normalize(L + V); float NdotH = max(0.0, dot(N, H)); float roughnessFactor = uRoughness * uRoughness; float shininess = pow(2.0, (1.0 - roughnessFactor) * 10.0) + 15.0; float specularStrength = pow(NdotH, shininess); vec3 F0 = vec3(0.04); vec3 specularColorBase = mix(F0, uBaseColor, uMetalness); vec3 specularComponent = specularColorBase * uVoxelLightColor * specularStrength; vec3 albedo = uBaseColor * (1.0 - uMetalness); vec3 finalColor = albedo * (diffuseLighting + uAmbientLightColor) + specularComponent; gl_FragColor = vec4(finalColor, 1.0); }`;

        function init() { scene = new THREE.Scene(); scene.background = new THREE.Color(0x1a1d24); clock = new THREE.Clock(); camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); updateCameraPosition(); renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth,window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio); document.getElementById('canvas-container').appendChild(renderer.domElement); controls = new OrbitControls(camera,renderer.domElement); controls.enableDamping=true; controls.dampingFactor=0.05; controls.target.set(0,0,0); ambientLight = new THREE.AmbientLight(params.sceneAmbientLight.color, params.sceneAmbientLight.intensity); scene.add(ambientLight); createMovableProbeSphere(); createCornerProbeSpheres(); createEncasingBox(); createAllPossibleLights(); createVoxelGrid(); createOrUpdateDominantDirectionLinesVisuals(); setupGUI(); setupInfoPanel(); window.addEventListener('resize',onWindowResize); }
        function createMovableProbeSphere() { const g=new THREE.SphereGeometry(params.probeSystem.radius,32,16);movableProbeSphereMaterial=new THREE.ShaderMaterial({uniforms:{uBaseColor:{value:new THREE.Color(params.probeSystem.color)},uRoughness:{value:params.probeSystem.roughness},uMetalness:{value:params.probeSystem.metalness},uVoxelLightDirection:{value:new THREE.Vector3(0,1,0)},uVoxelLightColor:{value:new THREE.Color(0)},uAmbientLightColor:{value:ambientLight.color.clone().multiplyScalar(ambientLight.intensity)},uVoxelDirectionCoherence:{value:0.5},uOmniDiffuseBase:{value:params.voxelVisuals.omniDiffuseBase}},vertexShader:probeVertexShader,fragmentShader:probeFragmentShader});movableProbeSphere=new THREE.Mesh(g,movableProbeSphereMaterial);movableProbeSphere.position.set(params.probeSystem.movableProbePosX,params.probeSystem.movableProbePosY,params.probeSystem.movableProbePosZ);movableProbeSphere.visible=params.probeSystem.movableProbeVisible;scene.add(movableProbeSphere); }
        function createCornerProbeSpheres() { const pG=new THREE.SphereGeometry(params.probeSystem.radius,32,16);const b=params.lightMovementBounds;const cO=[new THREE.Vector3(b.minX,b.minY,b.minZ),new THREE.Vector3(b.maxX,b.minY,b.minZ),new THREE.Vector3(b.minX,b.maxY,b.minZ),new THREE.Vector3(b.maxX,b.maxY,b.minZ),new THREE.Vector3(b.minX,b.minY,b.maxZ),new THREE.Vector3(b.maxX,b.minY,b.maxZ),new THREE.Vector3(b.minX,b.maxY,b.maxZ),new THREE.Vector3(b.maxX,b.maxY,b.maxZ),];cO.forEach(o=>{const m=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(movableProbeSphereMaterial.uniforms),vertexShader:probeVertexShader,fragmentShader:probeFragmentShader});m.uniforms.uBaseColor.value=new THREE.Color(params.probeSystem.color);m.uniforms.uRoughness.value=params.probeSystem.roughness;m.uniforms.uMetalness.value=params.probeSystem.metalness;m.uniforms.uOmniDiffuseBase.value=params.voxelVisuals.omniDiffuseBase;const p=new THREE.Mesh(pG.clone(),m);p.position.copy(o);p.visible=params.probeSystem.cornerProbesVisible;scene.add(p);cornerProbes.push(p);});}
        function clearCornerProbeSpheres() { cornerProbes.forEach(p=>{scene.remove(p);p.geometry.dispose();if(p.material.dispose)p.material.dispose();});cornerProbes=[];}
        function updateCameraPosition() { GRID_RESOLUTION=parseInt(params.gridResolution);VOXEL_PHYSICAL_SIZE=params.voxelPhysicalSize;const wE=GRID_RESOLUTION*VOXEL_PHYSICAL_SIZE;camera.position.set(wE*.9,wE*.7,wE*.9);}
        function clearVoxelVisuals() { voxelMeshes.forEach(r=>r.forEach(c=>c.forEach(m=>{if(m){scene.remove(m);m.geometry.dispose();m.material.dispose();}})));voxelGrid=[];voxelMeshes=[];}
        function clearEncasingBoxVisuals() { if(encasingBoxMesh){scene.remove(encasingBoxMesh);encasingBoxMesh.geometry.dispose();encasingBoxMesh.material.dispose();encasingBoxMesh=null;}}
        function clearDominantDirectionLinesVisuals() { if(dominantDirectionLinesMesh){scene.remove(dominantDirectionLinesMesh);if(dominantDirectionLinesGeometry)dominantDirectionLinesGeometry.dispose();dominantDirectionLinesMesh=null;dominantDirectionLinesGeometry=null;}visibleDirLinesCount=0;}
        function regenerateGridAndVisuals() { initParams();clearVoxelVisuals();clearEncasingBoxVisuals();clearDominantDirectionLinesVisuals();clearCornerProbeSpheres();clearAllPossibleLights();createVoxelGrid();createEncasingBox();createOrUpdateDominantDirectionLinesVisuals();createCornerProbeSpheres();createAllPossibleLights();updateCameraPosition();if(boundsFolderGUI)boundsFolderGUI.destroy();if(gui)createLightMovementBoundsGUI();lights.forEach(l=>{l.position.x=THREE.MathUtils.clamp(l.position.x,params.lightMovementBounds.minX,params.lightMovementBounds.maxX);l.position.y=THREE.MathUtils.clamp(l.position.y,params.lightMovementBounds.minY,params.lightMovementBounds.maxY);l.position.z=THREE.MathUtils.clamp(l.position.z,params.lightMovementBounds.minZ,params.lightMovementBounds.maxZ);});if(movableProbeSphere){movableProbeSphere.geometry.dispose();movableProbeSphere.geometry=new THREE.SphereGeometry(params.probeSystem.radius,32,16);}}
        function createEncasingBox() { const bS=GRID_RESOLUTION*VOXEL_PHYSICAL_SIZE+params.encasingBox.padding*2;const bG=new THREE.BoxGeometry(bS,bS,bS);const bM=new THREE.MeshBasicMaterial({color:params.encasingBox.color,transparent:true,opacity:params.encasingBox.opacity,side:THREE.BackSide,depthWrite:false});encasingBoxMesh=new THREE.Mesh(bG,bM);encasingBoxMesh.position.set(0,0,0);encasingBoxMesh.visible=params.encasingBox.visible;scene.add(encasingBoxMesh);}
        function clearAllPossibleLights() { lights.length=0;lightHelpers.forEach(h=>{if(h.parent)scene.remove(h);h.geometry.dispose();h.material.dispose();});lightHelpers.length=0;}
        function createAllPossibleLights() { clearAllPossibleLights();params.lightsParams.forEach((data,i)=>{const iV=new THREE.Vector3((Math.random()-.5)*1.8,(Math.random()-.5)*1.2,(Math.random()-.5)*1.8).normalize().multiplyScalar(1.7);const l={id:i,color:new THREE.Color(data.color),intensity:data.intensity,range:data.range,velocity:iV,helperOpacity:data.helperOpacity,_initialY:data.initialY,position:new THREE.Vector3(THREE.MathUtils.lerp(params.lightMovementBounds.minX,params.lightMovementBounds.maxX,Math.random()*.6+.2),data.initialY,THREE.MathUtils.lerp(params.lightMovementBounds.minZ,params.lightMovementBounds.maxZ,Math.random()*.6+.2))};lights.push(l);const hG=new THREE.SphereGeometry(params.lightHelperProps.sphereSize,32,16);const hM=new THREE.ShaderMaterial({uniforms:{uColor:{value:l.color},uOverallOpacity:{value:l.helperOpacity}},vertexShader:lightHelperVertexShader,fragmentShader:lightHelperFragmentShader,transparent:true,depthWrite:false,depthTest:params.lightHelperProps.depthTest});const h=new THREE.Mesh(hG,hM);h.position.copy(l.position);h.visible=params.showLightHelpers&&(i<params.numActiveLights);h.renderOrder=999;scene.add(h);lightHelpers.push(h);});}
        function createVoxelGrid() { const vG=new THREE.BoxGeometry(VOXEL_PHYSICAL_SIZE,VOXEL_PHYSICAL_SIZE,VOXEL_PHYSICAL_SIZE);const gWCO=(GRID_RESOLUTION-1)*VOXEL_PHYSICAL_SIZE/2;for(let x=0;x<GRID_RESOLUTION;x++){voxelGrid[x]=[];voxelMeshes[x]=[];for(let y=0;y<GRID_RESOLUTION;y++){voxelGrid[x][y]=[];voxelMeshes[x][y]=[];for(let z=0;z<GRID_RESOLUTION;z++){voxelGrid[x][y][z]={accumulatedColor:new THREE.Color(0),accumulatedIntensity:0,weightedDirectionSum:new THREE.Vector3(0,0,0),finalDominantLightDirection:new THREE.Vector3(0,1,0),directionCoherence:0.5,worldPosition:new THREE.Vector3(x*VOXEL_PHYSICAL_SIZE-gWCO,y*VOXEL_PHYSICAL_SIZE-gWCO,z*VOXEL_PHYSICAL_SIZE-gWCO)};const vM=new THREE.MeshStandardMaterial({color:0,emissive:0,transparent:true,opacity:params.voxelVisuals.minOpacity,side:THREE.BackSide,depthWrite:false});const v=new THREE.Mesh(vG,vM);v.position.copy(voxelGrid[x][y][z].worldPosition);scene.add(v);voxelMeshes[x][y][z]=v;}}}}
        function createOrUpdateDominantDirectionLinesVisuals() { clearDominantDirectionLinesVisuals();const mL=GRID_RESOLUTION**3;dominantDirectionLinesGeometry=new THREE.BufferGeometry();dirLinePositions=new Float32Array(mL*6);dirLineColors=new Float32Array(mL*6);dominantDirectionLinesGeometry.setAttribute('position',new THREE.BufferAttribute(dirLinePositions,3).setUsage(THREE.DynamicDrawUsage));dominantDirectionLinesGeometry.setAttribute('color',new THREE.BufferAttribute(dirLineColors,3).setUsage(THREE.DynamicDrawUsage));const lM=new THREE.LineBasicMaterial({vertexColors:true,depthTest:false,linewidth:1});dominantDirectionLinesMesh=new THREE.LineSegments(dominantDirectionLinesGeometry,lM);dominantDirectionLinesMesh.renderOrder=998;dominantDirectionLinesMesh.visible=params.debugVisuals.showDominantDirection;scene.add(dominantDirectionLinesMesh);visibleDirLinesCount=0;dominantDirectionLinesGeometry.setDrawRange(0,0);}
        function updateAndBakeVoxelLighting() { const gDAmbient=getGlobalAmbientDir();const gCAmbient=new THREE.Color(params.globalAmbientDirectional.color);const gIAmbient=params.globalAmbientDirectional.intensity;for(let x=0;x<GRID_RESOLUTION;++x)for(let y=0;y<GRID_RESOLUTION;++y)for(let z=0;z<GRID_RESOLUTION;++z){const v=voxelGrid[x][y][z];v.accumulatedColor.copy(gCAmbient).multiplyScalar(gIAmbient);v.accumulatedIntensity=gIAmbient;v.weightedDirectionSum.copy(gDAmbient).multiplyScalar(gIAmbient);v.directionCoherence=0.5;}for(let i=0;i<params.numActiveLights;++i){const light=lights[i];if(!light)continue;for(let x=0;x<GRID_RESOLUTION;++x)for(let y=0;y<GRID_RESOLUTION;++y)for(let z=0;z<GRID_RESOLUTION;++z){const v=voxelGrid[x][y][z];const dSq=v.worldPosition.distanceToSquared(light.position);const rSq=light.range*light.range;if(dSq<rSq){const d=Math.sqrt(dSq);let att=Math.max(0,(1-d/light.range)**2);const cLIV=light.intensity*att;v.accumulatedColor.add(light.color.clone().multiplyScalar(cLIV));v.accumulatedIntensity+=cLIV;const dTL=new THREE.Vector3().subVectors(light.position,v.worldPosition).normalize();v.weightedDirectionSum.addScaledVector(dTL,cLIV);}}}for(let x=0;x<GRID_RESOLUTION;++x)for(let y=0;y<GRID_RESOLUTION;++y)for(let z=0;z<GRID_RESOLUTION;++z){const v=voxelGrid[x][y][z];if(v.accumulatedIntensity > 1e-5){v.finalDominantLightDirection.copy(v.weightedDirectionSum).normalize();let sumOfCoherenceDots=0;let totalWeightForCoherence=0;for(let i=0;i<params.numActiveLights;++i){const light=lights[i];if(!light)continue;const dSq=v.worldPosition.distanceToSquared(light.position);const rSq=light.range*light.range;if(dSq<rSq){const d=Math.sqrt(dSq);let att=Math.max(0,(1-d/light.range)**2);const cLIV=light.intensity*att;if(cLIV > 1e-4){const dTL=new THREE.Vector3().subVectors(light.position,v.worldPosition).normalize();sumOfCoherenceDots+=v.finalDominantLightDirection.dot(dTL)*cLIV;totalWeightForCoherence+=cLIV;}}}if(totalWeightForCoherence>1e-5){const avgDot=sumOfCoherenceDots/totalWeightForCoherence;v.directionCoherence=(avgDot+1)*.5;}else if(v.accumulatedIntensity > gIAmbient + 1e-5){v.directionCoherence=1;}else{v.directionCoherence=0.5;}}else{v.finalDominantLightDirection.set(0,1,0);v.directionCoherence=0.5;}}const updateProbeUniforms=(pM,pP)=>{const pGX=Math.floor((pP.x+HALF_GRID_WORLD_SIZE)/VOXEL_PHYSICAL_SIZE);const pGY=Math.floor((pP.y+HALF_GRID_WORLD_SIZE)/VOXEL_PHYSICAL_SIZE);const pGZ=Math.floor((pP.z+HALF_GRID_WORLD_SIZE)/VOXEL_PHYSICAL_SIZE);const cPGX=THREE.MathUtils.clamp(pGX,0,GRID_RESOLUTION-1);const cPGY=THREE.MathUtils.clamp(pGY,0,GRID_RESOLUTION-1);const cPGZ=THREE.MathUtils.clamp(pGZ,0,GRID_RESOLUTION-1);const sV=voxelGrid[cPGX]?.[cPGY]?.[cPGZ];let lightDirForProbe=new THREE.Vector3(0,1,0);let lightColorForProbe=new THREE.Color(0);let coherenceForProbe=0.5;if(sV){lightColorForProbe.copy(sV.accumulatedColor);lightDirForProbe.copy(sV.finalDominantLightDirection);coherenceForProbe=sV.directionCoherence;}pM.material.uniforms.uVoxelLightColor.value.copy(lightColorForProbe);pM.material.uniforms.uVoxelLightDirection.value.copy(lightDirForProbe);pM.material.uniforms.uVoxelDirectionCoherence.value=coherenceForProbe;pM.material.uniforms.uOmniDiffuseBase.value=params.voxelVisuals.omniDiffuseBase;pM.material.uniforms.uAmbientLightColor.value.copy(ambientLight.color).multiplyScalar(ambientLight.intensity);pM.material.uniforms.uBaseColor.value.set(params.probeSystem.color);pM.material.uniforms.uRoughness.value=params.probeSystem.roughness;pM.material.uniforms.uMetalness.value=params.probeSystem.metalness;};if(movableProbeSphere&&movableProbeSphere.visible&&voxelGrid.length>0){updateProbeUniforms(movableProbeSphere,movableProbeSphere.position);}cornerProbes.forEach(p=>{if(p.visible&&voxelGrid.length>0){updateProbeUniforms(p,p.position);}});for(let x=0;x<GRID_RESOLUTION;++x)for(let y=0;y<GRID_RESOLUTION;++y)for(let z=0;z<GRID_RESOLUTION;++z){const v=voxelGrid[x][y][z];const m=voxelMeshes[x][y][z];const dIN=Math.min(v.accumulatedIntensity,params.voxelVisuals.intensityCap)/params.voxelVisuals.intensityCap;m.material.color.copy(v.accumulatedColor);m.material.opacity=THREE.MathUtils.lerp(params.voxelVisuals.minOpacity,params.voxelVisuals.maxOpacity,dIN);if(dIN>1e-3){m.material.emissive.copy(v.accumulatedColor).multiplyScalar(params.voxelVisuals.emissiveStrength*dIN);}else{m.material.emissive.setRGB(0,0,0);}m.visible=m.material.opacity>params.voxelVisuals.minOpacity+1e-4;}}
        function updateDominantDirectionLines() { if(!dominantDirectionLinesMesh||!dominantDirectionLinesGeometry)return;dominantDirectionLinesMesh.visible=params.debugVisuals.showDominantDirection;if(!dominantDirectionLinesMesh.visible){if(visibleDirLinesCount>0)dominantDirectionLinesGeometry.setDrawRange(0,0);visibleDirLinesCount=0;return;}let lI=0;const lL=params.debugVisuals.directionLineLength;for(let x=0;x<GRID_RESOLUTION;++x)for(let y=0;y<GRID_RESOLUTION;++y)for(let z=0;z<GRID_RESOLUTION;++z){const v=voxelGrid[x]?.[y]?.[z];if(v&&v.accumulatedIntensity>params.debugVisuals.directionMinIntensity){const sP=v.worldPosition;const eP=new THREE.Vector3().addVectors(sP,v.finalDominantLightDirection.clone().multiplyScalar(lL));const pI=lI*6;dirLinePositions[pI]=sP.x;dirLinePositions[pI+1]=sP.y;dirLinePositions[pI+2]=sP.z;dirLinePositions[pI+3]=eP.x;dirLinePositions[pI+4]=eP.y;dirLinePositions[pI+5]=eP.z;const c=v.accumulatedColor;dirLineColors[pI]=c.r;dirLineColors[pI+1]=c.g;dirLineColors[pI+2]=c.b;dirLineColors[pI+3]=c.r;dirLineColors[pI+4]=c.g;dirLineColors[pI+5]=c.b;lI++;if(lI>=GRID_RESOLUTION**3)break;}}visibleDirLinesCount=lI;if(visibleDirLinesCount>0){dominantDirectionLinesGeometry.attributes.position.needsUpdate=true;dominantDirectionLinesGeometry.attributes.color.needsUpdate=true;}dominantDirectionLinesGeometry.setDrawRange(0,visibleDirLinesCount*2);}
        function animateLights(deltaTime) { for(let i=0;i<params.numActiveLights;++i){const l=lights[i];if(!l)continue;l.position.addScaledVector(l.velocity,deltaTime*params.simulationSpeed);if(l.position.x<params.lightMovementBounds.minX||l.position.x>params.lightMovementBounds.maxX){l.position.x=THREE.MathUtils.clamp(l.position.x,params.lightMovementBounds.minX,params.lightMovementBounds.maxX);l.velocity.x*=-1;}if(l.position.y<params.lightMovementBounds.minY||l.position.y>params.lightMovementBounds.maxY){l.position.y=THREE.MathUtils.clamp(l.position.y,params.lightMovementBounds.minY,params.lightMovementBounds.maxY);l.velocity.y*=-1;}if(l.position.z<params.lightMovementBounds.minZ||l.position.z>params.lightMovementBounds.maxZ){l.position.z=THREE.MathUtils.clamp(l.position.z,params.lightMovementBounds.minZ,params.lightMovementBounds.maxZ);l.velocity.z*=-1;}}lightHelpers.forEach((h,i)=>{if(lights[i]){h.position.copy(lights[i].position);h.material.uniforms.uColor.value.copy(lights[i].color);h.material.uniforms.uOverallOpacity.value=lights[i].helperOpacity;h.material.depthTest=params.lightHelperProps.depthTest;h.visible=params.showLightHelpers&&(i<params.numActiveLights);}else{h.visible=false;}});}
        function createLightMovementBoundsGUI() { if(!gui)return;boundsFolderGUI=gui.addFolder('Light Movement Bounds');const cMB=GRID_RESOLUTION*VOXEL_PHYSICAL_SIZE/2;boundsFolderGUI.add(params.lightMovementBounds,'minX',-cMB,0,0.1).name('Min X');boundsFolderGUI.add(params.lightMovementBounds,'maxX',0,cMB,0.1).name('Max X');boundsFolderGUI.add(params.lightMovementBounds,'minY',-cMB,0,0.1).name('Min Y');boundsFolderGUI.add(params.lightMovementBounds,'maxY',0,cMB,0.1).name('Max Y');boundsFolderGUI.add(params.lightMovementBounds,'minZ',-cMB,0,0.1).name('Min Z');boundsFolderGUI.add(params.lightMovementBounds,'maxZ',0,cMB,0.1).name('Max Z');}
        function updateLightGUIFoldersVisibility() {lightGUIfolders.forEach((folder,index)=>{if(folder&&folder.domElement){folder.domElement.style.display=(index<params.numActiveLights)?'block':'none';}});}
        function setupInfoPanel() {const infoButton=document.getElementById('infoButton');const infoPanel=document.getElementById('info-panel');if(infoButton&&infoPanel){infoPanel.classList.remove('hidden');infoButton.textContent='Hide Info';infoButton.onclick=()=>{const isHidden=infoPanel.classList.toggle('hidden');infoButton.textContent=isHidden?'Show Info':'Hide Info';};controls.addEventListener('start',()=>{if(!infoPanel.classList.contains('hidden')){infoPanel.classList.add('hidden');infoButton.textContent='Show Info';}}); } const dateEl = document.getElementById('infoPanelDate'); if(dateEl) { const now = new Date(); dateEl.textContent = now.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }); }}
        function setupGUI() {gui=new GUI();gui.title("VibeVoxelProbes Controls");const wF=gui.addFolder('Grid & World Settings');wF.add(params,'gridResolution',{'8':'8','10':'10','12':'12','16':'16'}).name('Grid Res.').onChange(regenerateGridAndVisuals);wF.add(params,'voxelPhysicalSize',.2,2,.05).name('Voxel Size').onChange(regenerateGridAndVisuals);const gF=gui.addFolder('General Settings');gF.add(params,'numActiveLights',1,MAX_POSSIBLE_LIGHTS,1).name('# Active Lights').onChange(updateLightGUIFoldersVisibility);gF.add(params,'showLightHelpers').name('Show Helpers').onChange(v=>lightHelpers.forEach((h,i)=>h.visible = v && (i < params.numActiveLights)));gF.add(params,'simulationSpeed',.1,10,.1).name('Light Sim Speed');gF.addColor(params.sceneAmbientLight,'color').name('Scene Ambient').onChange(v=>ambientLight.color.set(v));gF.add(params.sceneAmbientLight,'intensity',0,5,.05).name('Scene Amb. Intens.').onChange(v=>ambientLight.intensity=v);const gADF=gui.addFolder('Global Ambient Directional');gADF.add(params.globalAmbientDirectional,'intensity',0,5,.01).name('Intensity');gADF.addColor(params.globalAmbientDirectional,'color').name('Color');gADF.add(params.globalAmbientDirectional,'directionX',-1,1,.01).name('Dir X');gADF.add(params.globalAmbientDirectional,'directionY',-1,1,.01).name('Dir Y');gADF.add(params.globalAmbientDirectional,'directionZ',-1,1,.01).name('Dir Z');const vF=gui.addFolder('Voxel Visuals');vF.add(params.voxelVisuals,'minOpacity',0,.5,.005).name('Min Opacity');vF.add(params.voxelVisuals,'maxOpacity',0,1,.01).name('Max Opacity');vF.add(params.voxelVisuals,'emissiveStrength',0,20,.05).name('Emissive Strength');vF.add(params.voxelVisuals,'intensityCap',.1,50,.1).name('Intensity Cap');vF.add(params.voxelVisuals,'omniDiffuseBase',0,1,.01).name('Omni Diffuse Base').onChange(v=>{if(movableProbeSphereMaterial)movableProbeSphereMaterial.uniforms.uOmniDiffuseBase.value=v;cornerProbes.forEach(p=>p.material.uniforms.uOmniDiffuseBase.value=v);});const bF=gui.addFolder('Encasing Box');bF.add(params.encasingBox,'visible').name('Show Box').onChange(v=>encasingBoxMesh.visible=v);bF.add(params.encasingBox,'opacity',0,.5,.01).name('Opacity').onChange(v=>encasingBoxMesh.material.opacity=v);bF.addColor(params.encasingBox,'color').name('Color').onChange(v=>encasingBoxMesh.material.color.set(v));bF.add(params.encasingBox,'padding',0,2,.1).name('Padding').onChange(v=>{const s=GRID_RESOLUTION*VOXEL_PHYSICAL_SIZE+v*2;encasingBoxMesh.geometry.dispose();encasingBoxMesh.geometry=new THREE.BoxGeometry(s,s,s);});const lHF=gui.addFolder('Light Helpers (General)');lHF.add(params.lightHelperProps,'sphereSize',.05,.5,.01).name('Helper Sphere Size').onChange(s=>{lightHelpers.forEach(h=>{if(h.geometry)h.geometry.dispose();h.geometry=new THREE.SphereGeometry(s,32,16);});});lHF.add(params.lightHelperProps,'depthTest').name('Helper Depth Test');createLightMovementBoundsGUI();const dF=gui.addFolder('Debug Visuals');dF.add(params.debugVisuals,'showDominantDirection').name('Show Dominant Dir.');dF.add(params.debugVisuals,'directionLineLength',.05,VOXEL_PHYSICAL_SIZE*1.5,.01).name('Dir. Line Length');dF.add(params.debugVisuals,'directionMinIntensity',0,10,.005).name('Dir. Min Intensity');
            const probeSysFolder=gui.addFolder('Probe System');probeSysFolder.add(params.probeSystem,'movableProbeVisible').name('Movable Vis.').onChange(v=>movableProbeSphere.visible=v);probeSysFolder.add(params.probeSystem,'cornerProbesVisible').name('Corners Vis.').onChange(v=>cornerProbes.forEach(p=>p.visible=v));probeSysFolder.add(params.probeSystem,'radius',.1,VOXEL_PHYSICAL_SIZE*2,.01).name('Radius').onChange(r=>{if(movableProbeSphere){movableProbeSphere.geometry.dispose();movableProbeSphere.geometry=new THREE.SphereGeometry(r,32,16);}cornerProbes.forEach(p=>{if(p.geometry)p.geometry.dispose();p.geometry=new THREE.SphereGeometry(r,32,16);});});probeSysFolder.addColor(params.probeSystem,'color').name('Base Color').onChange(c=>{if(movableProbeSphereMaterial)movableProbeSphereMaterial.uniforms.uBaseColor.value.set(c);cornerProbes.forEach(p=>p.material.uniforms.uBaseColor.value.set(c));});probeSysFolder.add(params.probeSystem,'roughness',0,1,.01).name('Roughness').onChange(r=>{if(movableProbeSphereMaterial)movableProbeSphereMaterial.uniforms.uRoughness.value=r;cornerProbes.forEach(p=>p.material.uniforms.uRoughness.value=r);});probeSysFolder.add(params.probeSystem,'metalness',0,1,.01).name('Metalness').onChange(m=>{if(movableProbeSphereMaterial)movableProbeSphereMaterial.uniforms.uMetalness.value=m;cornerProbes.forEach(p=>p.material.uniforms.uMetalness.value=m);});const pPM=HALF_GRID_WORLD_SIZE+params.encasingBox.padding;probeSysFolder.add(params.probeSystem,'movableProbePosX',-pPM,pPM,.05).name('Movable X').onChange(x=>movableProbeSphere.position.x=x);probeSysFolder.add(params.probeSystem,'movableProbePosY',-pPM,pPM,.05).name('Movable Y').onChange(y=>movableProbeSphere.position.y=y);probeSysFolder.add(params.probeSystem,'movableProbePosZ',-pPM,pPM,.05).name('Movable Z').onChange(z=>movableProbeSphere.position.z=z);
            lightGUIfolders=[];params.lightsParams.forEach((data,i)=>{const lFo=gui.addFolder(`Light ${i+1}`);lFo.add(data,'intensity',.1,20,.05).name('Intensity').onChange(v=>lights[i]?(lights[i].intensity=v):null);lFo.add(data,'range',1,GRID_RESOLUTION*VOXEL_PHYSICAL_SIZE*3,.1).name('Range').onChange(v=>lights[i]?(lights[i].range=v):null);lFo.addColor(data,'color').name('Color').onChange(v=>lights[i]?lights[i].color.set(v):null);lFo.add(data,'helperOpacity',0,1,.01).name('Helper Opacity').onChange(v=>lights[i]?(lights[i].helperOpacity=v):null);if(lights[i]){lFo.add(lights[i].position,'y',params.lightMovementBounds.minY,params.lightMovementBounds.maxY,.1).name('Current Y Pos').listen();}lightGUIfolders.push(lFo);});updateLightGUIFoldersVisibility();}
        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight); }
        function animate() { requestAnimationFrame(animate);const d=clock.getDelta();animateLights(d);updateAndBakeVoxelLighting();updateDominantDirectionLines();controls.update();renderer.render(scene,camera); }
        init();animate();
    </script>
</body>
</html>
